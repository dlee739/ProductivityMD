#include "todo_list.h"


/*!
 * \brief todo_list::todo_list
 * This is the constructor for the todo_list class
 * The constructor will read in all the to-do list tasks not completed for the logged in user and store into the list
 */
todo_list::todo_list() {
    string task_title;
    int task_id;
    sqlite3_stmt* statement;
    size = 0;

    // query below is used against the sqlite3 database and will get all the rows in the todo_task table with the user id of the currently logged in user
    // this will return all the to-do tasks for the logged in user
    string todo_sql = "SELECT todoId, todoTitle FROM todo_task WHERE todoUserId = " + to_string(user::get_instance().get_id()) + ";";
    sqlite3_prepare_v2(Database::get_instance().get_db(), todo_sql.c_str(), -1, &statement, 0); // Converts sql query into byte-code program - necessary to execute an SQL statement

    while (sqlite3_step(statement) != SQLITE_DONE){ // loop will get the records in the table row by row
        task_id = sqlite3_column_int(statement, 0); // get the task id
        task_title = string(reinterpret_cast<const char*>(sqlite3_column_text(statement, 1))); // get the task title

        todo_list_task task(task_id, task_title);  // create a new todo_list_task object with the id and title - this object is a representation for a specific to-do task
        todo_tasks.insert(todo_tasks.begin(), task); // add the new todo_list_task object into the vector

        size++;
    }

    sqlite3_finalize(statement); // deletes the prepared statement
}

// Destructor
todo_list::~todo_list() {

}

/*!
 * \brief todo_list::get_title_at
 * \param index
 * \return the title in string of indexed task in string
 * This method returns the title of a task positioned in given index of the todo list vector
 */
string todo_list::get_title_at(int index) {
    return todo_tasks.at(index).getTitle();
}

/*!
 * \brief todo_list::search_by_taskId
 * \param id
 * \return the title in string of the specified task
 * This method searches for a specific task given its id, and returns its title
 */
string todo_list::search_by_taskId(int id) {
    for (int i = 0; i < todo_tasks.size(); i++) { // iterate through todo list
        if (todo_tasks.at(i).getTaskId() == id) { // matching id found
            return todo_tasks.at(i).getTitle();  // returns title of the todo task
        }
    }
    return NULL; // no such task found
}

/*!
 * \brief todo_list::search_by_taskTitle
 * \param title
 * \return the task id in int corresponding to the given title
 * This method searches for a specific task given its title, and returns its id
 */
int todo_list::search_by_taskTitle(string title) {
    for (int i = 0; i < todo_tasks.size(); i++) { // iterate through todo list
        if (title.compare(todo_tasks.at(i).getTitle()) == 0) { // matching title found
            return todo_tasks.at(i).getTaskId();
        }
    }
    return -1; // no such task found
}

/*!
 * \brief todo_list::getSize
 * \return the size in int
 * This method returns the size of todo list
 */
int todo_list::getSize() {
    return size;
}

/*!
 * \brief todo_list::insert
 * \param new_task
 * Insert a newly created task into the sqlite database and into the list of tasks
 */
void todo_list::insert(string new_task) {
    // code below will insert the new task created into the the sqlite3 database
    char* err;  // used to store any errors generated by the sqlite3 exec() function
    string insert_todo_sql = "INSERT INTO todo_task (todoTitle, todoUserId) VALUES ('" +  new_task + "', " + to_string(user::get_instance().get_id()) +  "); "; // query to insert task into databse
    int status1 = sqlite3_exec(Database::get_instance().get_db(), insert_todo_sql.c_str(), NULL, 0, &err); // executes the insertion into the database
    if (status1 != SQLITE_OK) {
        cout << "Cannot insert new task into sqlite3 database." << endl;
        sqlite3_free(err);
        return;
    } else {
        cout << "New task inserted into sqlite database successfully." << endl;
    }

    // After inserting into the database, we need to retrieve the task id of the new task
    // because the task id of the newly inserted task is generated when it is inserted into the database due to autoincrement
    // therefore, we need to query the database to retrieve the id for the newly created task and store that with the task object in the list
    int taskid = -1; // default value
    sqlite3_stmt* statement;
    // query below will get the task id for the newly created task
    string taskid_todo_sql = "SELECT MAX(todoId) FROM todo_task WHERE todoUserId = " + to_string(user::get_instance().get_id()) + " AND todoTitle = '" + new_task + "';";
    cout << "taskid_todo_sql: " << taskid_todo_sql << endl;
    sqlite3_prepare_v2(Database::get_instance().get_db(), taskid_todo_sql.c_str(), -1, &statement, 0); // Converts sql query into byte-code program - necessary to execute an SQL statement
    int status = sqlite3_step(statement);
    cout << "status: " << status << endl;
    if (status == SQLITE_DONE){ // task doesn't exist
        cout << "Cannot retrieve recently created task from sqlite3 database." << endl;
        return;
    } else {
        cout << "Successfully retrieved recent task from sqlite3 database." << endl;
        taskid = sqlite3_column_int(statement, 0); // get the task id and store in variable
        cout << "taskid: " << taskid << endl;
    }
    sqlite3_finalize(statement); // deletes the prepared statement

    // Object creation
    todo_list_task newtask (taskid, new_task);  // create a new todo_list_task object for the new task
    todo_tasks.insert(todo_tasks.begin(), newtask); // insert the new task into the list

    size++; // increment count for number of tasks
}

/*!
 * \brief todo_list::remove_task
 * \param task
 * This method removes a given task from current todo list
 */
void todo_list::remove_task(string task) {
    // code below will delete the completed task from the database
    char* err;
    int task_id = search_by_taskTitle(task);  // get the task id of the task to be deleted
    string remove_todo_sql = "DELETE FROM todo_task WHERE todoId = " + to_string(task_id) + ";"; // query to delete the task from the database using the task id
    int status1 = sqlite3_exec(Database::get_instance().get_db(), remove_todo_sql.c_str(), NULL, 0, &err);  // execute deletion
    if (status1 != SQLITE_OK) {
        cout << "Cannot remove this task from sqlite3 database." << endl;
        sqlite3_free(err);
        return;
    } else {
        cout << "This task removed from the sqlite database successfully." << endl;
    }

    // need to delete the todo_list_task object of the completed task from the vector/list
    for (vector<todo_list_task>::iterator it = todo_tasks.begin(); it != todo_tasks.end(); it++) { // iterate through the vector
        if (it->getTaskId() == task_id) { // find the task with the matching id as the task deleted
            it = todo_tasks.erase(it); // remove the task from the vector
            size--; // decrement count of tasks in the list
            break;
        }
    }


}
